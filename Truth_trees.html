<!DOCTYPE html><html><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><!--replace-start-0--><!--replace-start-5--><!--replace-start-8--><title>Truth trees - </title><!--replace-end-8--><!--replace-end-5--><!--replace-end-0--><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><link href="https://fonts.googleapis.com/css?family=Merriweather|Libre+Franklin|Roboto+Mono&amp;display=swap" rel="stylesheet" /><!--replace-start-1--><!--replace-start-4--><!--replace-start-7--><link href="static/favicon.ico" rel="icon" /><meta content="Like truth-tables, truth-trees are a means of graphically representing the logical relationships that may obtain between propositions. Truth-trees and truth-tables complement each other and which method you choose depends on which logical property you are seeking to derive." name="description" /><meta content="Truth trees" property="og:title" /><meta content="" property="og:site_name" /><meta content="article" property="og:type" /><meta content="Truth_trees" property="neuron:zettel-id" /><meta content="Truth_trees" property="neuron:zettel-slug" /><meta content="logic" property="neuron:zettel-tag" /><meta content="propositional-logic" property="neuron:zettel-tag" /><script type="application/ld+json">[]</script><style type="text/css">body{background-color:#eeeeee !important;font-family:"Libre Franklin", serif !important}body .ui.container{font-family:"Libre Franklin", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Merriweather", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body .zettel-content h1#title-h1{background-color:rgba(33,133,208,0.1)}body nav.bottomPane{background-color:rgba(33,133,208,2.0e-2)}body div#footnotes{border-top-color:#2185d0}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.94999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.container.universe{padding-top:1em}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content div#footnotes ol > li > p:only-of-type{display:inline;margin-right:0.5em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f5f2f0}body div.zettel-view .zettel-content pre{overflow:auto}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.bottomPane ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body nav.bottomPane ul.context-list > li{list-style-type:lower-roman}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}body span.zettel-link-container span.zettel-link a{color:#2185d0;font-weight:bold;text-decoration:none}body span.zettel-link-container span.zettel-link a:hover{background-color:rgba(33,133,208,0.1)}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}</style><script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" rel="stylesheet" />
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
	href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=IBM+Plex+Sans+Condensed:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=IBM+Plex+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=IBM+Plex+Serif:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap"
	rel="stylesheet" />
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap"
	rel="stylesheet" />
<link href="https://hachyderm.io/@systemsobscure" rel="me" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js"></script>
<style>
	:root {
		font-synthesis: none;
		text-rendering: optimizeLegibility;
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: grayscale;

		--black: #282828;
		--blacker: #1d2021;
		--blackest: #141617;

		--greyLightest: #a89984;
		--greyLighter: #928374;
		--greyLight: #665c54;
		--grey: #504945;
		--greyDark: #3c3836;
		--greyDarkest: #32302f;

		--white: #ddc7a1;
		--whiter: #ebdbb2;

		--blue: #7daea3;
		--green: #a9b665;
		--aqua: #8dc07c;
		--yellow: #d8a657;
		--orange: #e78a4e;
		--red: #ea6962;
		--purple: #d3869b;

		--blueOriginal: #458588;
		--greenOriginal: #98971a;
		--orangeOriginal: #d65d0e;
	}

	body .ui.container,
	body ul {
		font-family: "IBM Plex Sans" !important;
	}

	body h2,
	body div.zettel-view .zettel-content h2 {
		border-bottom: none !important;
	}

	body blockquote {
		border-left-width: 3px !important;
		border-left-color: var(--orange) !important;
		background-color: var(--blacker) !important;
	}

	.headerFont,
	.ui.header,
	body h1,
	h2,
	h3,
	h4,
	h5,
	h6 {
		font-family: "IBM Plex Sans" !important;
	}

	body p {
		/* line-height: 1.3; */
	}

	.monoFont,
	body code,
	pre,
	tt {
		font-family: "Jetbrains Mono" !important;
		font-size: 12px !important;
		/* line-height: 1.3 !important; */
	}

	img[alt~="not-by-ai-badge"] {
		width: 100px;
	}

	#neuron-nav-bar {
		background-color: var(--orange);
	}

	#neuron-nav-bar a.right {
		display: none;
	}

	.ui .center img {
		display: none;
	}

	body {
		background-color: var(--blacker) !important;
		color: var(--white);
	}

	.zettel-view article.zettel-content {
		background-color: var(--black) !important;
	}

	a,
	body span.zettel-link-container span.zettel-link a,
	body .deemphasized:not(:hover) a {
		color: var(--aqua) !important;
	}

	.deemphasized:not(:hover) a {
		color: var(--aqua) !important;
	}

	body .zettel-content h1#title-h1 {
		background-color: var(--orange);
		color: var(--black);
		word-wrap: break-word;
	}

	.ui.raised.raised.segment,
	.ui.raised.raised.segments {
		box-shadow: none;
	}

	.ui.raised.attached.segment.zettel-content {
		border: none;
	}

	#neuron-backlinks-pane,
	#neuron-tags-pane {
		background-color: var(--greyDark);
		border: none;
	}

	#neuron-backlinks-pane h3.ui.header,
	#neuron-backlinks-pane p,
	#neuron-backlinks-pane>ul>li>ul>li>div {
		color: var(--white) !important;
	}

	#neuron-backlinks-pane ul li::marker {
		color: var(--white) !important;
	}

	#neuron-backlinks-pane>ul>li>ul>li>div>p>a,
	#neuron-backlinks-pane ul li span.zettel-link a {
		color: var(--aqua) !important;
	}

	body .deemphasized:not(:hover),
	body .deemphasized:hover {
		opacity: 1;
	}

	#neuron-nav-bar {
		border-radius: 0;
	}

	.ui.basic.label.zettel-tag {
		background-color: var(--orange);
		border-radius: 0;
		border: none;
		color: var(--black);
	}

	body div.zettel-view .zettel-content p code,
	li code,
	ol code {
		padding: 0;
		font-size: 13px !important;
		background: transparent;
	}

	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}

	.ui table {
		background-color: var(--blacker) !important;
		border-radius: 0 !important;
		border-color: var(--greyDark) !important;
		color: var(--white) !important;
	}

	.ui.table>thead>tr>th {
		background-color: var(--greyDark) !important;
		border-radius: 0 !important;
		color: var(--white) !important;
	}

	body span.zettel-link-container.errors {
		border-color: var(--red);
	}

	body span.zettel-link-container.errors span.zettel-link a {
		color: var(--red) !important;
	}

	body span.zettel-link-container.errors span.zettel-link a:hover {
		background-color: #fb483460 !important;
	}

	code[class*="language-"],
	pre[class*="language-"] {
		color: #ebdbb2;
		/* fg1 / fg */
		direction: ltr;
		text-align: left;
		white-space: pre;
		word-spacing: normal;
		word-break: normal;
		line-height: 1.2;

		-moz-tab-size: 4;
		-o-tab-size: 4;
		tab-size: 4;

		-webkit-hyphens: none;
		-moz-hyphens: none;
		-ms-hyphens: none;
		hyphens: none;
	}

	pre[class*="language-"]::-moz-selection,
	pre[class*="language-"] ::-moz-selection,
	code[class*="language-"]::-moz-selection,
	code[class*="language-"] ::-moz-selection {
		color: #fbf1c7;
		/* fg0 */
		background: #7c6f64;
		/* bg4 */
	}

	pre[class*="language-"]::selection,
	pre[class*="language-"] ::selection,
	code[class*="language-"]::selection,
	code[class*="language-"] ::selection {
		color: #fbf1c7;
		/* fg0 */
		background: #7c6f64;
		/* bg4 */
	}

	/* Code blocks */
	pre[class*="language-"] {
		padding: 0.75rem;
		margin: 0.5rem 0;
		overflow: auto;
	}

	:not(pre)>code[class*="language-"],
	pre[class*="language-"] {
		background-color: #32302f;
		/* border-width: 3px;
  border-color: #665c54;
  border-style: double; */
		/* border: 1px solid #504945; */
	}

	/* Inline code */
	:not(pre)>code[class*="language-"] {
		padding: 0.1em;
		border-radius: 0;
		border-width: 1px;
		background: transparent;
	}

	.token.comment,
	.token.prolog,
	.token.cdata {
		color: #a89984;
		/* fg4 / gray1 */
	}

	.token.delimiter,
	.token.boolean,
	.token.keyword,
	.token.selector,
	.token.important,
	.token.atrule {
		color: #ea6962;
		/* red2 */
	}

	.token.operator,
	.token.punctuation,
	.token.attr-name {
		color: #a89984;
		/* fg4 / gray1 */
	}

	.token.tag,
	.token.tag .punctuation,
	.token.doctype,
	.token.builtin {
		color: #d8a657;
		/* yellow2 */
	}

	.token.entity,
	.token.number,
	.token.symbol {
		color: #d3869b;
		/* purple2 */
	}

	.token.property,
	.token.constant,
	.token.variable {
		color: #ea6962;
		/* red2 */
	}

	.token.string,
	.token.char {
		color: #89b482;
		/* green2 */
	}

	.token.attr-value,
	.token.attr-value .punctuation {
		color: #a89984;
		/* fg4 / gray1 */
	}

	.token.url {
		color: #89b482;
		/* green2 */
		text-decoration: underline;
	}

	.token.function {
		color: #a9b665;
		/* yellow2 */
	}

	.token.regex {
		background: #b8bb26;
		/* green2 */
	}

	.token.bold {
		font-weight: bold;
	}

	.token.italic {
		font-style: italic;
	}

	.token.inserted {
		background: #a89984;
		/* fg4 / gray1 */
	}

	.token.deleted {
		background: #ea6962;
		/* red2 */
	}

	.token.operator {
		background: transparent !important;
	}
</style>
<!--replace-end-7--><!--replace-end-4--><!--replace-end-1--></head><body><div class="ui fluid container universe"><!--replace-start-2--><!--replace-start-3--><!--replace-start-6--><div class="ui text container" id="zettel-container" style="position: relative"><div class="zettel-view"><article class="ui raised attached segment zettel-content"><div class="pandoc"><h1 id="title-h1">Truth trees</h1><h2 id="rationale">Rationale</h2><p>Like <span class="zettel-link-container errors"><span class="zettel-link" title="Wiki-link does not refer to any existing zettel"><a>Truth-tables</a></span></span>, truth-trees are a means of graphically representing the logical relationships that may obtain between propositions. Truth-trees and truth-tables complement each other and which method you choose depends on which logical property you are seeking to derive.</p><p>Whilst truth-tables have the benefit of being exhaustive - every possible truth assignment is factored into the representation - their complexity grows exponentially with each additional proposition they contain. This can make manually constructing truth tables long-winded and prone to mistakes.</p><p>Truth-trees are less onerous but they lack the exhaustive scope of a truth-table. They are more targeted and are best used for demonstrating <em>that something is the case</em> rather than <em>all the possible states that could be the case</em>. For example, a truth tree will tell us that a set <em>S is logically consistent</em> whereas a truth-table will tell us that <em>S is consistent on the following three assignments.</em></p><h2 id="logical-consistency">Logical consistency</h2><p>Recall that a set of propositions is logically or truth-functionally <span class="zettel-link-container errors"><span class="zettel-link" title="Wiki-link does not refer to any existing zettel"><a>Consistency</a></span></span> just if there is at least one assignment of truth conditions which results in all members of the set being true. To identify consistency for a set of three propositions via the truth table approach we would need to construct a truth table with <span class="math inline">\(2^3\)</span> (8) rows. Assume that this set is consistent on one partial assignment only. This means that 87.5% of our rows are redundant, they are not required to prove the consistency of the set. However we can only know this and we can only be sure of consistency once we have gone through the process of generating an assignment for each row.</p><p>Truth trees allow us to reduce the amount of work required and go straight to the assignment that proves consistency, disregarding the rest which are irrelevant.</p><h2 id="truth-tree-structure-and-key-terms">Truth tree structure and key terms</h2><p><strong>When using a truth tree to derive logical consistency, the goal is to determine whether there is a truth-value assignment on which all of the sentences of a set are true. If the set is consistent we should be able to derive a partial assignment from the tree that demonstrates consistency.</strong></p><p>Each truth tree begins with a series of sentences one on top of the other in a column. We call the sentences that comprise the initial column <strong>set members</strong>. In constructing the tree, we work downwards from the initial column decomposing set members into their atomic constituents. We a call an atomic sentence that has been decomposed a <strong>literal.</strong> A literal will either be an atomic sentence or the negation of an atomic sentence. If one of the set members is already a literal, there is no need to decompose it; it can remain as it is.</p><p>Once every set member has been decomposed the truth tree is complete. It can then be interpreted in order to derive logical consistency or inconsistency. If the set is consistent, we are able to derive the partial assignment(s) that demonstrate consistency.</p><p>The rules for decomposing compound sentences match the truth conditions of the logical connectives. There are rules for every possible connective and the negation of every possible connective however in terms of their tree shape they all correspond to either a conjunction or a disjunction. Disjunctive decomposition results in new branches being formed off the main column (or trunk). Conjunctive decomposition is non-branching which means the decomposed constituents are placed within the trunk of whichever tree or branch they are decomposed within.</p><p>As we construct the tree we list each line in the left-hand margin and the decomposition rule in the right-hand margin. When we apply a decomposition rule we must cite the lines to which it applies.</p><h3 id="closed-and-open-branches">Closed and open branches</h3><p>Any branch on which an atomic sentence (<span class="math inline">\(P\)</span>) and the negation of that sentence (<span class="math inline">\(\sim P\)</span>) both occur is a <strong>closed branch</strong>. A branch that is not closed is an <strong>open branch</strong>. No partial assignment is recoverable from a closed branch. An open branch allows truth to ‘flow up’ to the original set members whereas a closed branch blocks this passage.</p><h3 id="completed-open-branch">Completed open branch</h3><p>A completed open branch occurs when we have an open branch that has been fully decomposed: the branch is open and all molecular sentences have been ticked off such that it contains only literals.</p><h3 id="completed-tree">Completed tree</h3><p>A tree where all its branches are either completed open branches or closed branches.</p><h3 id="closed-tree">Closed tree</h3><p>A tree where all the branches are closed</p><h3 id="open-tree">Open tree</h3><p>A tree with at least one completed open branch</p><h2 id="deriving-consistency">Deriving consistency</h2><p>Using the definitions above, we can now define truth-functional consistency and inconsistency in terms of truth trees:</p><blockquote><p>A finite set (<span class="math inline">\(\Gamma\)</span> ) of sentences is truth-functionally inconsistent if <span class="math inline">\(\Gamma\)</span> is a closed tree</p></blockquote><blockquote><p>A finite set (<span class="math inline">\(\Gamma\)</span> ) of sentences is truth-functionally consistent if <span class="math inline">\(\Gamma\)</span> is an open tree</p></blockquote><h2 id="examples">Examples</h2><h3 id="first-example">First example</h3><p>The following is a truth tree for the set <span class="math inline">\({P \lor Q, \sim P }\)</span>:</p><p><img alt="basic-open-tree 1.svg" src="static/basic-open-tree%201.svg" /></p><h3 id="interpretation">Interpretation</h3><ul><li>We decompose the disjunction at line 1 on line 3. We tick off the compound sentence to indicate that it is now decomposed and no longer under consideration.</li><li>Both P and its negation exist on a single branch (at line 2 and line 3). This makes it a closed branch. We indicate this by the X beneath the branch that is closed, citing the source of the closure by line number.</li><li>The rightward branch is a completed open branch given the decomposition at 3 and the lack of negation of Q. Overall this makes the tree an open tree.</li></ul><p>As the set gives us an open tree, it must be truth-functionally consistent. If this is the case we should be able to determine the partial assignment in which each set member is true. Given that Q is not negated the assignment of consistency will contain Q but we have both P and ~P. This means there are two possible assignments where the set is consistent: <span class="math inline">\(P, Q\)</span> and <span class="math inline">\(\sim P, Q\)</span>. This is confirmed by the truth-table:</p><pre><code class="language-none">P	Q				P	∨	~	P				Q
T	T					T						T     *
T	F					T						F
F	T					T						T     *
F	F					T						F</code></pre><p><strong>Any time there is an open tree with a closed branch it will be the case that the negated sentences of the closed branch will appear both as</strong> <span class="math inline">\(S\)</span> and <span class="math inline">\(\sim S\)</span> i<strong>n the resultant assignment.</strong></p><p>Invoking the truth-table highlights the differences between the two techniques. The values that are derived when we interpret a truth tree are not the truth-functions of the set members but the truth-values for when they are simultaneously true. With truth-tables in contrast, we are deriving the truth functions for every possible truth-value assignment. In other words the values derived from a truth tree correspond to the left hand side of the truth table not the right hand side.</p><h3 id="second-example">Second example</h3><p>The following is a truth tree for the set <span class="math inline">\({A &amp; \sim B, C, \sim A \lor \sim B }\)</span>.</p><p><img alt="basic-closed-tree 1.svg" src="static/basic-closed-tree%201.svg" /></p><h3 id="interpretation-1">Interpretation</h3><ul><li>The two molecular set members are decomposed. The disjunction (line 3) results in a branching tree. The conjunction (line 1) results in the continuation of the trunk.</li><li>Both branches are completed making it a completed tree. As each branch is closed this is a closed tree.</li></ul><p>As this is a closed tree, the set is not truth-functionally consistent. This is confirmed by the truth table where there is no partial assignment where all set members are true.</p><pre><code class="language-none">A	B	C				A	&amp;	~	B				C				~	A	∨	~	C
T	T	T					F						T						F
T	T	F					F						F						T
T	F	T					T						T						F
T	F	F					T						F						T
F	T	T					F						T						T
F	T	F					F						F						T
F	F	T					F						T						T
F	F	F					F						F						T</code></pre><h2 id="truth-tree-decomposition-rules">Truth tree decomposition rules</h2><hr /><p>So far we have encountered the decomposition rules for conjunction (<code>&amp;D</code>) and disjunction (<code>vD</code>). We will now list all the rules. We will see that for each rule, the decomposition either branches or does not branch which is to say that each rule either has the shape of a conjunction or a disjunction (however the permitted values of the specific disjuncts/conjuncts obviously differ in each case). Moreover there is a parallel rule for the decomposition of the negation of each of the main connectives and these rules rely on logical equivalences</p><h3 id="negated-negation-decomposition-d">Negated negation decomposition: <code>~~D</code></h3><p><img alt="negated-negation-decomposition-rule 2.svg" src="static/negated-negation-decomposition-rule%202.svg" /></p><p>Truth passes only if <span class="math inline">\(P\)</span> is true</p><h3 id="conjunction-decomposition-d">Conjunction decomposition: <code>&amp;D</code></h3><p><img alt="conjunction-decomposition-rule.svg" src="static/conjunction-decomposition-rule.svg" /></p><p>Truth passes only <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> are both true.</p><h3 id="negated-conjunction-decomposition-d">Negated Conjunction decomposition: <code>~&amp;D</code></h3><p><img alt="negated-conjunction-decomposition-rule.svg" src="static/negated-conjunction-decomposition-rule.svg" /></p><p>Truth passes if either <span class="math inline">\(\sim P\)</span> or <span class="math inline">\(\sim Q\)</span> is true. This rule is a consequence of the equivalence between <span class="math inline">\(\sim (P &amp; Q)\)</span> and <span class="math inline">\(\sim P \lor \sim Q\)</span> , the first of DeMorgan’s Laws.</p><h3 id="disjunction-decomposition-vd">Disjunction decomposition: <code>vD</code></h3><p><img alt="disjunction-decomposition-rule.svg" src="static/disjunction-decomposition-rule.svg" /></p><p>Truth passes if either <span class="math inline">\(P\)</span>or <span class="math inline">\(Q\)</span> are true.</p><h3 id="negated-disjunction-decomposition-vd">Negated Disjunction decomposition: <code>~vD</code></h3><p><img alt="negated-disjunction-decomposition-rule.svg" src="static/negated-disjunction-decomposition-rule.svg" /></p><p>Truth passes if both <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> are false. This rule is a consequence of the equivalence between <span class="math inline">\(\sim (P \lor Q)\)</span> and <span class="math inline">\(\sim P &amp; \sim Q\)</span>, the second of DeMorgan’s Laws.</p><h3 id="conditional-decomposition-d">Conditional decomposition: <code>⊃D</code></h3><p><img alt="conditional-decomposition-rule.svg" src="static/conditional-decomposition-rule.svg" /></p><p>Truth passes if either <span class="math inline">\(\sim P\)</span> or <span class="math inline">\(Q\)</span> are true. This rule is a consequence of the equivalence between <span class="math inline">\(P \supset Q\)</span> and <span class="math inline">\(\sim P \lor Q\)</span> therefore this branch has the shape of a disjunction with <span class="math inline">\(\sim P\)</span> , <span class="math inline">\(Q\)</span> as its disjuncts.</p><h3 id="negated-conditional-decomposition-d">Negated Conditional decomposition: <code>~⊃D</code></h3><p>Truth passes if both <span class="math inline">\(P\)</span> and <span class="math inline">\(\sim Q\)</span> are true. This is a consequence of the equivalence between <span class="math inline">\(\sim (P \supset Q)\)</span> and <span class="math inline">\(P &amp; \sim Q\)</span>.</p><p><img alt="negated-conditional-decomposition-rule.svg" src="static/negated-conditional-decomposition-rule.svg" /></p><h3 id="biconditional-decomposition-d">Biconditional decomposition: <code>≡D</code></h3><p><img alt="biconditional-decomposition-rule.drawio(1).svg" src="static/biconditional-decomposition-rule.drawio%281%29.svg" /></p><p>Truth passes if either <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> are true or <span class="math inline">\(\sim P &amp; \sim Q\)</span> are true. This is an interesting rule because it combines the disjunction and conjunction tree shapes.</p><h3 id="negated-biconditional-decomposition-d">Negated biconditional decomposition: <code>~≡D</code></h3><p><img alt="negated-biconditional-decomposition-rule.drawio.svg" src="static/negated-biconditional-decomposition-rule.drawio.svg" /></p><p>Truth passes if either <span class="math inline">\(P\)</span> and <span class="math inline">\(\sim Q\)</span> is true or if <span class="math inline">\(\sim P\)</span> and <span class="math inline">\(Q\)</span> is true.</p><h2 id="further-examples-and-heuristics-for-complex-truth-trees">Further examples and heuristics for complex truth trees</h2><p>With truth-trees regardless of which order you decompose the set members, the conclusion should always be the same. This said, there more are more efficient ways than others to construct the trees. You want to find the route that will demonstrate consistency or non-consistency with the shortest amount of work. The following heuristic techniques followed in order, facilitate this:</p><ol><li>Decompose those molecular sentences the decomposition of which does not produce new branches. In other words that are decompositions of double negations or pure conjunctions.</li><li>Perform those decompositions that will rapidly generate closed branches.</li><li>If neither (1) or (2) is applicable, decompose <strong>the most complex</strong> sentence first.</li></ol><p>Here are some examples of these rules applied:</p><p><img alt="complex-tree.svg" src="static/complex-tree.svg" /></p><p>Observe that here we don’t bother to decompose the sentence on line 1. This is because, having decomposed the sentences on lines 2 and 3 we have arrived at a closed tree. It is therefore unnecessary to go any further for if two sentences in the set are inconsistent with each other, adding another sentence is not going to change the overall assignment of inconsistency.</p><h2 id="deriving-properties-other-than-logical-consistency-from-truth-trees">Deriving properties other than logical consistency from truth trees</h2><p>So far truth trees have been discussed purely in terms of logical consistency however they can be used to derive all the other key truth-functional properties of propositional logic. Given the foundational role of consistency to logic, these properties are expressible in terms of consistency which is what makes them amenable to formulation in terms of truth trees.</p><h3 id="logical-falsity">Logical falsity</h3><p>For a given finite set <span class="math inline">\(\Gamma\)</span>, <span class="math inline">\(\Gamma\)</span> is logically consistent just if all of its members can be true at once. Expressed in terms of truth trees, this is equivalent to an open tree. Contrariwise, <span class="math inline">\(\Gamma\)</span> is inconsistent if it is not possible for every member of the set to be true at once. This is the same as a tree where all of the branches are closed (i.e. a closed tree).</p><p>When we wish to assess <a href="Logical%20truth%20and%20falsity.md#logical-falsity">logical falsity</a> we are not focused on sets however, we are interested in a property of a sentence. However we can easily construe single sentences as unit sets: sets with a single member. With this in mind and the above accounts of consistency and logical falsity we are equipped to express logical falsity in terms of truth-trees with the following rule:</p><blockquote><p>A sentence <span class="math inline">\(P\)</span> is logically false if and only if the unit set <span class="math inline">\({ P }\)</span> has a closed tree</p></blockquote><p>A logically false sentence cannot be true on any assignment. This is the same thing as an inconsistent set. Thus it will be represented in a truth tree as inconsistency which is disclosed via a closed tree.</p><p><img alt="logical-falsity-tree.svg" src="static/logical-falsity-tree.svg" /></p><h3 id="logical-truth">Logical truth</h3><p>For a sentence <span class="math inline">\(P\)</span> to be <a href="Logical%20truth%20and%20falsity.md#logical-truth">logically true</a>, there must be no possible assignment in which <span class="math inline">\(P\)</span> is false. We express this informally by saying <em>it is not possible to consistently deny <span class="math inline">\(P\)</span>.</em> We know that in terms of truth trees an inconsistent set is a closed tree therefore a unit set of <span class="math inline">\({ P }\)</span> is logically true if <span class="math inline">\({ \sim P }\)</span> is a closed tree. This is to say: if the negation of <span class="math inline">\(P\)</span> is inconsistent.</p><blockquote><p>A sentence <span class="math inline">\(P\)</span> is logically true if and only if the set <span class="math inline">\({ \sim P }\)</span> has a closed tree</p></blockquote><h3 id="logical-indeterminacy">Logical indeterminacy</h3><p><span class="zettel-link-container errors"><span class="zettel-link" title="Wiki-link does not refer to any existing zettel"><a>Indeterminacy</a></span></span> follows from the two definitions above; we do not require any additional apparatus. We recall that a sentence <span class="math inline">\(P\)</span> is logically indeterminate just if it is neither logically true or logically false. Thus the truth tree for an indeterminate sentence is straightforward:</p><blockquote><p>A sentence <span class="math inline">\(P\)</span> is logically indeterminate if and only if neither the set  <span class="math inline">\({ P }\)</span> nor the set <span class="math inline">\({ \sim P }\)</span> has a closed tree</p></blockquote><p>This follows because a closed tree for  <span class="math inline">\({ P }\)</span> means it is not logically false and an open tree for <span class="math inline">\({ \sim P }\)</span> means it is not logically true. So if it is neither of these things, <span class="math inline">\(P\)</span> must be indeterminate.</p><h3 id="logical-equivalence">Logical equivalence</h3><p>Recall that <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> are <a href="Logical%20equivalence.md">logically equivalent</a> just if there is no truth assignment on which one is true and the other is false. We know from the <a href="Corresponding%20material%20and%20biconditional.md#corresponding-material-biconditional">material biconditional shorthand</a> that this state of affairs can be expressed as $P \equiv Q$ and that if this compound sentence is true on every assignment then both simple sentences are equivalent. But ‘true on every assignment’ is another way of saying <em>logically true</em> since there is no possibility of a false assignment. We already know what logical truth looks like as a truth tree: it is a closed tree for the negation of the sentence being tested. Therefore, to test the logical equivalence of two sentences it is necessary to construct a truth tree for the negation of the sentences conjoined by the biconditional (i.e. <span class="math inline">\(\sim (P \equiv Q)\)</span> )and see if this results in a closed tree. If it does, the two sentences are logically equivalent.</p><blockquote><p>Sentences <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> are truth-functionally equivalent if and only if the set <span class="math inline">\(\sim (P \equiv Q)\)</span> has a closed tree</p></blockquote><p><img alt="logical-equivalence-tree.svg" src="static/logical-equivalence-tree.svg" /></p><h3 id="logical-entailment-and-validity">Logical entailment and validity</h3><p>Let’s remind ourselves of the meaning of truth-functional <a href="Validity%20and%20entailment.md#entailment">entailment</a> and <a href="Validity%20and%20entailment.md#validity">validity</a> and the relation between the two. <span class="math inline">\(\Gamma\)</span> <span class="math inline">\(\vdash\)</span> <span class="math inline">\(P\)</span> is true if and only if there is no truth-assignment in which every member of <span class="math inline">\(\Gamma\)</span> is true and <span class="math inline">\(P\)</span> is false. Entailment is closely related to validity; it is really just a matter of emphasis: we say that <span class="math inline">\(\Gamma\)</span> are the premises and <span class="math inline">\(P\)</span> is the conclusion and that this is a valid argument if there is no assignment in which every member of <span class="math inline">\(\Gamma\)</span> is true and <span class="math inline">\(P\)</span> is false.</p><p>As with the previous properties, to express validity and entailment in terms of truth trees we need to express these concepts in the language of logical consistency. <span class="math inline">\(\Gamma\)</span> entails <span class="math inline">\(P\)</span> just if one cannot consistently assert <span class="math inline">\(\Gamma\)</span> whilst denying <span class="math inline">\(P\)</span>. This is to say that the set <span class="math inline">\(\Gamma \cup {\sim P}\)</span> is inconsistent. So we just need a closed truth tree for <span class="math inline">\(\Gamma \cup {\sim P}\)</span> to demonstrate the validity of this set.</p><blockquote><p>A finite set of sentences <span class="math inline">\(\Gamma\)</span> truth-functionally entails a sentence <span class="math inline">\(P\)</span> if and only if the set <span class="math inline">\(\Gamma \cup {\sim P}\)</span> has a closed truth tree.</p></blockquote><blockquote><p>An argument is truth functionally valid if and only if the set consisting of the premises and the negation of the conclusion has a closed truth tree.</p></blockquote></div></article><nav class="ui attached segment deemphasized bottomPane" id="neuron-tags-pane"><div><span class="ui basic label zettel-tag" title="Tag">logic</span><span class="ui basic label zettel-tag" title="Tag">propositional-logic</span></div></nav><nav class="ui bottom attached icon compact inverted menu blue" id="neuron-nav-bar"><!--replace-start-9--><!--replace-end-9--><a class="right item" href="impulse" title="Open Impulse"><i class="wave square icon"></i></a></nav></div></div><!--replace-end-6--><!--replace-end-3--><!--replace-end-2--><div class="ui center aligned container footer-version"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron 1.9.35.3" /></a></div></div></div></body></html>